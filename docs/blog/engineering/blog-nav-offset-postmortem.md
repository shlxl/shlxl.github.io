---
title: 博客导航间距调试复盘
date: "2025/09/27 20:00:00"
description: 记录为博客首页头像卡片与列表卡片寻找正确顶部间距的多轮调试过程，总结屡次翻车的根因与今后可复用的排查手法。
tags: [工程实践, CSS, 调试复盘]
categories: [工程实践]
publish: true
draft: false
---

> TL;DR：页面确实对齐了，但花了比预期多好几轮。复盘下来，问题不是 CSS 难，而是流程疏漏：缺乏事实校验、把不同场景共用一个变量、没有建立逐条验证的 checklist。

## 背景

博客首页采用主题自带的双列布局：左列为头像卡片（`blog-info-wrapper`），右列为文章列表（`blog-list-wrapper`）。头像列使用 `position: sticky`，需要在桌面端让卡片顶部恰好贴在导航条底部，否则滚动时会出现“紧贴导航”或“错位一个像素”的体验问题。前几轮修改虽然尝试了 `margin-top`、`padding-top` 与自定义变量，但都未达到视觉预期。

## 失误 1：假设值成立而不测量

第一次修改直接给两列套用了一个自定义变量 `--blog-columns-top-offset`，并把它与 `--vp-nav-height` 做 `calc()` 叠加。问题在于我假设导航高度恒定且变量取值正确，没有在浏览器里读取真实的 `--vp-nav-height`，更没有检查 sticky 元素的 `top` 计算结果。事实是主题本身已经把 `top` 设为 `var(--vp-nav-height)`，我额外增加的偏移让卡片反而贴在导航下缘。

**经验教训**：涉及布局的魔法数字必须先测量后编码，至少用一次 DevTools 查看计算后的像素值。

## 失误 2：共享变量掩盖了不同组件的职责

为了让两列对齐，我把同一个偏移变量同时作用在头像列与列表列。这样虽然语义“同步”，但也把两个组件耦合到一起：当我尝试调整列表的 `padding` 时，头像列的 `top` 也被动跟着变化，导致要么两者都错、要么只能靠目测微调。最终我才意识到 sticky 列和滚动列的需求完全不同：前者需要一个绝对的锚点，后者只需要和它对齐的起点。

**经验教训**：不要为了“看起来优雅”而把职责绑在一个变量里；组件式思维应该让每个部分只关心自己的约束条件。

## 失误 3：缺少逐条验证的流程

前两轮修改后，我没有按照需求逐条回归：

1. 是否在 ≥960px 的桌面宽度下检查？
2. sticky 卡片在滚动时是否保持与导航的固定间距？
3. 列表第一篇文章的顶部是否与头像卡片底部对齐？

缺乏 checklist 让我在“看起来差不多”的状态下就提交了修改，直到用户指出“离导航只有 0px”才意识到还差关键一步。

**经验教训**：只要需求涉及特定视口与交互，就应在提交前列出验证项并逐一确认。

## 最终方案

- 桌面端：`blog-info-wrapper` 的 `top` 回归为 `var(--vp-nav-height)`，明确表达“紧贴导航底部”。
- 列表列：单独使用 `padding-top` 确保第一篇文章的文本基线与头像卡片顶部一致。
- 移动端：保留 `top: 20px`，避免覆盖整屏的导航。

这样 sticky 列拥有自己的锚点，而列表列只负责视觉对齐，滚动联动自然成立。

## 往后怎么做

1. **先测量后编码**：DevTools 读取变量、查看 box model，确保心中有数。
2. **职责分离**：在 CSS 中也坚持单一职责原则，避免“一个变量管天下”。
3. **建立验证清单**：把需求拆成可检查的条目，提交前逐项确认。
4. **记录复盘**：像本文一样保留排错过程，为后续类似场景提供参考。

这次的折腾提醒我：工程实践的难点往往不是语法，而是流程和习惯。保持“先验证再提交”的节奏，才能把简单问题真正简单化。
